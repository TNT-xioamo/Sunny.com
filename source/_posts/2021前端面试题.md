---
title: 整理一些前端面试题
tags: [面试，前端]
index_img: /article-img/Fall.jpg
categories: 
date: 2022-03-31
mermaid: true
---
<!-- 回流一定会引起重绘，重绘不一定会引起回流。 -->
## JS 相关
  JacvaScript中的call()和apply()方法
  call和apply可以用来重新定义函数的执行环境，也就是this的指向；call和apply都是为了改变某个函数运行时的context，即上下文而存在的，换句话说，就是为了改变函数体内部this的指向。
  call方法可以用来代替另一个对象调用一个方法，call方法可以将一个函数的对象上下文从初始的上下文改变为obj指定的新对象，如果没有提供obj参数，那么Global对象被用于obj。
  apply()和call()方法一样，只是参数列表不同 如果argArray不是一个有效数组或不是arguments对象，那么将导致一个TypeError，如果没有提供argArray和obj任何一个参数，那么Global对象将用作obj。

  相同点:
  call()和apply()方法的相同点就是这两个方法的作用是一样的。都是在特定的作用域中调用函数，等于设置函数体内this对象的值，以扩充函数赖以运行的作用域。

## 彻底弄懂 Promise 原理
Promise 必须为以下三种状态之一：等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）。一旦Promise 被 resolve 或 reject，不能再迁移至其他任何状态（即状态 immutable）。
 1. 初始化 Promise 状态（pending）
 2. 立即执行 Promise 中传入的 fn 函数，将Promise 内部 resolve、reject 函数作为参数传递给 fn ，按事件机制时机处理
 3. 执行 then(..) 注册回调处理数组（then 方法可被同一个 promise 调用多次）
 4. Promise里的关键是要保证，then方法传入的参数 onFulfilled 和 onRejected，必须在then方法被调用的那一轮事件循环之后 的新执行栈中执行。
  三个状态：
  pending、fulfilled、reject
  两个过程：
  padding -> fulfilled、padding -> rejected当pending为rejectd时，会进入catch

  ### Promise.all和Promise.race的区别的使用场景
（1）Promise.all
  Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。
  Promise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。
  需要注意，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。
（2）Promise.race
  顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：

  ### 说说浏览器和node中的事件循环（EventLoop）
  浏览器中相对简单，共有两个事件队列，当主线程空闲时会清空Microtask queue(微任务队列)依次执行Task Queue(宏任务队列)中的回调函数，每执行完一个之后再清空Microtask queue。
  “当前执行栈” -> “micro-task” -> “task queue中取一个回调” -> “micro-task” -> ... (不断消费task queue) -> “micro-task”

  node中机制和浏览器有一些差异。node中的task queue是分为几个阶段，清空micro-task是在一个阶段结束之后(浏览器中是每一个任务结束之后)
  这里我们主要关注其中的3个阶段：timer、poll和check，其中poll队列相对复杂：
  轮询 阶段有两个重要的功能：
  1、计算应该阻塞和轮询 I/O 的时间。
  2、然后，处理 轮询 队列里的事件。
  当事件循环进入 轮询 阶段且 没有计划计时器时 ，将发生以下两种情况之一：
    1、如果轮询队列不是空的，事件循环将循环访问其回调队列并同步执行它们，直到队列已用尽，或者达到了与系统相关的硬限制。
    2、如果轮询队列是空的，还有两件事发生：
    a、如果脚本已按 setImmediate() 排定，则事件循环将结束 轮询 阶段，并继续 check阶段以执行这些计划脚本。
    b、如果脚本 尚未 按 setImmediate()排定，则事件循环将等待回调添加到队列中，然后立即执行。
  一旦轮询队列为空，事件循环将检查已达到时间阈值的计时器。如果一个或多个计时器已准备就绪，则事件循环将绕回计时器阶段以执行这些计时器的回调。




  ### 宏任务和微任务
    同步任务（synchronous）和异步任务（asynchronous）。同步阻塞异步非阻塞。
    同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务，例如alert，会阻塞后续任务的执行，只有在点击确定之后，才会执行下一个任务。
    异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。
    单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。所以会有任务队列的概念。正因为是单线程，所以所有任务都是主线程执行的，异步请求这些也不会开辟新的线程，而是放到任务队列，当这  些 异步操作被触发时才进入主线程执行。
    JS任务又分为宏任务和微任务。
    宏任务（macrotask）：setTimeout、setInterval、setImmediate、I/O、UI rendering
    微任务（microtask）：promise.then、process.nextTick、MutationObserver、queneMicrotask(开启一个微任务)
    了解了宏任务和微任务的执行顺序，就可以了解到为何nextTick 要优先使用Promise和MutationObserver 因为他俩属于微任务，会在执行栈空闲的时候立即执行，它的响应速度相比setTimeout会更快，因为无需 等渲染。
    而setImmediate和setTimeout属于宏任务，执行开始之前要等渲染，即task->渲染->task。  

  ### 垃圾回收机制
  v8的垃圾回收策略主要基于分代式垃圾回收机制。将内存分为新生代和老生代，分别采用不同的算法。

  新生代采用Scavenge算法
  Scavenge为新生代采用的算法，是一种采用复制的方式实现的垃圾回收算法。它将内存分为from和to两个空间。每次gc,会将from空间的存活对象复制到to空间。然后两个空间角色对换(又称反转)。
  该算法是牺牲空间换时间，所以适合新生代，因为它的对象生存周期较短。
  v8的内存限制:
  64位系统最大约为1.4G
  32位系统最大约为0.7G

  ### 了解的设计模式
  1. 发布订阅模式 在js中事件模型就相当于传统的发布订阅模式
  2. 策略模式  定义： 定义一系列算法，把它们一个个封装起来，并且使它们可以相互替换。
  3. 命令模式 应用场景： 有时候我们要向某些对象发送请求，但不知道请求的接收者是谁，也不知道请求的操作是什么，此时希望以一种松耦合的方式来设计软件，使得请求的发送者和接收者能够消除彼此的耦合关系。
  ### ES6 模块与 CommonJS 模块的差异
  1. CommonJS输出的是值的拷贝，ES6模块输出的是值的引用。
    也就是说CommonJS引用后改变模块内变量的值，其他引用模块不会改变，而ES6模块会改变。
  2. CommonJS是运行时加载，ES6模块是编译时输出接口。 
    之所以Webpack的Tree Shaking是基于ES6的，就是因为ES6在编译的时候就能确定依赖。因为使用babel-preset-2015这个预设默认是会把ES6模块编译为CommonJS的，所以想使用Tree Shaking还需要手动修改这个预设。
  
  
  async函数实现原理:
  async函数是基于generator实现，所以涉及到generator相关知识。在没有async函数之前，通常使用co库来执行generator 所以通过co我们也能模拟async的实现。




## ES6 相关整理
1. import、export导入导出ES6标准中，Js原生支持模块(module)。将JS代码分割成不同功能的小块进行模块化，将不同功能的代码分别写在不同文件中，各模块只需导出公共接口部分，然后通过模块的导入的方式可以在其他地方使用

2. set数据结构Set数据结构，类似数组。所有的数据都是唯一的，没有重复的值。它本身是一个构造函数

3. 解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值

4. let声明变量和const声明常量，两个都有块级作用域ES5中是没有块级作用域的，并且var有变量提升，在let中，使用的变量一定要进行声明

5. 修饰器 @decorator是一个函数，用来修改类甚至于是方法的行为。修饰器本质就是编译时执行的函数

6. class 类的继承ES6中不再像ES5一样使用原型链实现继承，而是引入Class这个概念11）async、await使用 async/await, 搭配promise,可以通过编写形似同步的代码来处理异步流程, 提高代码的简洁性和可读性async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成

7. Symbol是一种基本类型。Symbol 通过调用symbol函数产生，它接收一个可选的名字参数，该函数返回的symbol是唯一的

8. Proxy代理使用代理（Proxy）监听对象的操作，然后可以做一些相应事情

 ### 使用箭头函数应注意什么？
 (1）用了箭头函数，this就不是指向window，而是父级（指向是可变的）
（2）不能够使用arguments对象
（3）不能用作构造函数，这就是说不能够使用new命令，否则会抛出一个错误
（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数

 ### 介绍下 Set、Map的区别？
  应用场景Set用于数据重组，Map用于数据储存Set：　
  （1）成员不能重复
  （2）只有键值没有键名，类似数组
  （3）可以遍历，方法有add, delete,has
  Map:
  （1）本质上是健值对的集合，类似集合
  （2）可以遍历，可以跟各种数据格式转换

  ### 继承的方式有那几种？
  原型链继承
  父类的实例作为子类的原型
  借用构造函数继承（伪造对象、经典继承）
  复制父类的实例属性给子类
  实例继承（原型式继承）
  组合式继承
  调用父类构造函数，继承父类的属性，通过将父类实例作为子类原型，实现函数复用
  寄生组合继承
  通过寄生的方式来修复组合式继承的不足，完美的实现继承

  ### iterable类型
  为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型，具有iterable类型的集合可以通过新的for … of循环来遍历。

## VUE 相关
  #### 计算属性computed :
  支持缓存，只有依赖数据发生改变，才会重新进行计算
  不支持异步，当computed内有异步操作时无效，无法监听数据的变化
  computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数  据通过计算得到的值
  如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed5.如果computed属性属性值  是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调 用set方法。

  #### 侦听属性watch：
  不支持缓存，数据变，直接会触发相应的操作；
  watch支持异步；
  监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；
  当一个属性发生变化时，需要执行对应的操作；一对多；
  监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数。immediate：组件  加载立即触发回调函数执行；deep: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监  听数组的变动不需要这么做。注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异,只有以响应式的方式触发才会被监听到。
  当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。这是watch和computed最大的区别。


  vue3: Composition Api 与 Vue 2.x使用的Options Api 有什么区别？Options Api包含一个描述组件选项（data、methods、props等）的对象 options；API开发复杂组件，同一个功能逻辑的代码被拆分到不同选项 ；使用mixin重用公用代码，也有问题：命名冲突，数据来源不清晰；composition Apivue3 新增的一组 api，它是基于函数的 api，可以更灵活的组织组件的逻辑。解决options api在大型项目中，options api不好拆分和重用的问题。
  2.Proxy 相对于 Object.defineProperty
  有哪些优点？proxy的性能本来比defineproperty好，proxy可以拦截属性的访问、赋值、删除等操作，不需要初始化的时候遍历所有属性，另外有多层属性嵌套的话，只有访问某个属性的时候，才会递归处理下一级的属性。可以* 监听数组变化可以劫持整个对象操作时不是对原对象操作,是 new Proxy 返回的一个新对象可以劫持的操作有 13 种

  Vue.js 3.0 响应式系统的实现原理？
  1. reactive
  设置对象为响应式对象。接收一个参数，判断这参数是否是对象。不是对象则直接返回这个参数，不做响应式处理。创建拦截器handerler，设置get/set/deleteproperty。

    get
    收集依赖（track）；
    如果当前 key 的值是对象，则为当前 key 的对
    象创建拦截器 handler, 设置 get/set/deleteProperty；
    如果当前的 key 的值不是对象，则返回当前 key 的值。
    set
    设置的新值和老值不相等时，更新为新值，并触发更新（trigger）。deleteProperty 当前对象有这个 key 的时候，删除这个 key 并触发更新（trigger）。
  2. effect
  接收一个函数作为参数。作用是：访问响应式对象属性时去收集依赖

  3.track
  接收两个参数：target 和 key－如果没有 activeEffect，则说明没有创建 effect 依赖－如果有 activeEffect，则去判断 WeakMap 集合中是否有 target 属性－WeakMap 集合中没有 target 属性，则 set(target, (depsMap = new Map()))－WeakMap 集合中有 target 属性，则判断 target 属性的 map 值的 depsMap 中是否有 key 属性－depsMap 中没有 key 属性，则 set(key, (dep = new Set())) －depsMap 中有 key 属性，则添加这个 activeEffect

  4. trigger
  判断 WeakMap 中是否有 target 属性，WeakMap 中有 target 属性，则判断 target 属性的 map 值中是否有 key 属性，有的话循环触发收集的 effect()。

  vue.js 3.x中标记和提升所有的静态节点，diff的时候只需要对比动态节点内容；


  ### mpVue 相关
  实例生命周期 同 vue，不同的是我们会在小程序 onReady 后，再去触发 vue mounted 生命周期，详细的 vue 生命周期

  app 部分：
    onLaunch，初始化
    onShow，当小程序启动，或从后台进入前台显示
    onHide，当小程序从前台进入后台
    
    小程序里所有的 BOM／DOM 都不能用，也就是说 v-html 指令不能用。 不支持javaScript复杂逻辑渲染 message.split('').reverse().join('')
    不支持在 template 内使用 methods 中的函数。

